/*
 Navicat MySQL Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 80016
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80016
 File Encoding         : 65001

 Date: 21/03/2024 21:25:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ms_admin
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin`;
CREATE TABLE `ms_admin`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_admin
-- ----------------------------
INSERT INTO `ms_admin` VALUES (1, 'admin', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');

-- ----------------------------
-- Table structure for ms_admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin_permission`;
CREATE TABLE `ms_admin_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_id` bigint(20) NOT NULL,
  `permission_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_admin_permission
-- ----------------------------
INSERT INTO `ms_admin_permission` VALUES (1, 1, 1);
INSERT INTO `ms_admin_permission` VALUES (2, 2, 1);

-- ----------------------------
-- Table structure for ms_article
-- ----------------------------
DROP TABLE IF EXISTS `ms_article`;
CREATE TABLE `ms_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_counts` int(11) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(11) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(11) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(20) NULL DEFAULT NULL COMMENT '作者id',
  `body_id` bigint(20) NULL DEFAULT NULL COMMENT '内容id',
  `category_id` bigint(20) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1770444117323571202 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article
-- ----------------------------
INSERT INTO `ms_article` VALUES (1, 21, 1621947720727, '通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。', 'springboot介绍以及入门案例', 14, 0, 1, 1, 2);
INSERT INTO `ms_article` VALUES (9, 5, 1613947720727, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。', 'Vue.js 到底是什么', 24, 0, 1, 20, 2);
INSERT INTO `ms_article` VALUES (10, 14, 1523947720727, '本节将介绍如何在项目中使用 Element。', 'Element相关', 40, 0, 1, 21, 2);
INSERT INTO `ms_article` VALUES (1405916999732707300, 3, 1624031708047, 'springboot入门案例', 'SpringBoot入门案例', 13, 0, 1, 1405916999854342146, 2);
INSERT INTO `ms_article` VALUES (1608050952827342850, 16, 1672224197944, '暂无', '60天速成驾照', 144, 0, 1592051100003860482, 1608050952940589058, 3);
INSERT INTO `ms_article` VALUES (1662117613662142466, 10, 1685114694402, '供考试使用', '软件需求说明书', 68, 0, 1592051100003860482, 1662117613662142468, 2);
INSERT INTO `ms_article` VALUES (1760583060186779650, 3, 1708590686247, 'Atcoder竞赛的题解分享\n涉及算法有：\n模拟\n模拟\n模拟 + map统计\n质数筛 + 前缀和\n序列哈希化 + 前缀和', 'AtCoder Contest 250 部分题解', 60, 0, 1597801008459800578, 1760583060224528387, 2);
INSERT INTO `ms_article` VALUES (1760687849444749313, 13, 1708615669955, '深度优先搜索的例题', '数独（dfs算法）', 152, 0, 1592051100003860482, 1760687849461526530, 5);
INSERT INTO `ms_article` VALUES (1770444117323571201, 1, 1710941745478, '介绍SpringAop基本概念和它的一些注解的使用方法', 'SpringAop', 4, 0, 1597801008459800578, 1770444117457788930, 2);

-- ----------------------------
-- Table structure for ms_article_body
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_body`;
CREATE TABLE `ms_article_body`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1770444117457788931 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article_body
-- ----------------------------
INSERT INTO `ms_article_body` VALUES (1, '# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n', '<h2>2018-01-04</h2>\n<pre><code class=\"lang-\"># 使用vue的Webpack模板生成脚手架\n</code></pre>\n<h2>2018-01-05</h2>\n<pre><code class=\"lang-\"># 引入ElementUI\n\n# babel-plugin-component自定义主题\n# 首页\n# 登陆页\n# 注册页面\n# 日志页\n</code></pre>\n<h2>2018-01-07</h2>\n<pre><code class=\"lang-\"># 调整底部栏始终固定在底部\n# 日志页 添加时间轴\n# 首页的文章列表\n</code></pre>\n<h2>2018-01-08</h2>\n<pre><code class=\"lang-\"># 使用组件-博客作者tab页 \n# 添加第三方图标\n</code></pre>\n<h2>2018-01-09</h2>\n<pre><code class=\"lang-\"># 调整顶部导航栏：激活文字颜色，click点击\n# 组件-最新文章tab页\n\n# 最新文章、最热文章使用相同组件\n# 底部栏设计\n# 页面与两边边距改为100\n</code></pre>\n<h2>2018-01-10</h2>\n<pre><code class=\"lang-\"># 写博客 引入mavonEditor编辑器\n# 顶部导航栏都放入一个Menu中\n# 写文章页面\n#　mavonEditor局部引入\n\n#　页面的中间区域固定宽度，自动居中\n# 发布和取消\n# 发布dialog\n\n</code></pre>\n<h2>2018-01-11</h2>\n<pre><code class=\"lang-\"># 文章组件用守卫来改变body背景色\n# 调整登陆和注册页面，使其居中\n\n#子页面调整根元素为div\n#文章详情页\n\n</code></pre>\n<h2>2018-01-12</h2>\n<pre><code class=\"lang-\"># 文章详情页  内容  评论等\n\n</code></pre>\n<h2>2018-01-13</h2>\n<pre><code class=\"lang-\">## 重新调整页面结构	\n#顶部和底部 抽成  BaseHeader BaseFooter 组件\n#BlogView为单独页，以前是Home的子路由\n\n</code></pre>\n<h2>2018-01-15</h2>\n<pre><code class=\"lang-\"># 文章分类去掉子级\n# 将首页的文章列表抽成 ArticleItem组件\n# 增加文章的评论展示\n# 增加文章分类、标签页\n\n</code></pre>\n<h2>2018-01-15  2</h2>\n<pre><code class=\"lang-\"># 回到顶部去掉过渡动画（影响顶部导航栏）\n# 顶部导航栏 增加登录后菜单\n# 首页增加 最热标签\n# 增加 文章分类 标签的详情页\n# 将文章详情页、 文章分类标签页 改为Home的子路由（以前单独页）\n# Home组件增加路由判断：更正导航栏的状态、条件显示底部栏\n\n</code></pre>\n<h2>2018-01-16</h2>\n<pre><code class=\"lang-\"># 将写文章的顶部Header合并到BaseHeader中\n# 图片都放到了static目录下\n\n</code></pre>\n<h2>2018-01-24</h2>\n<pre><code class=\"lang-\"># 将自定义的theme放到assets下\n# 加入axios\n# 加入vuex\n# 实现登录\n# 实现退出\n\n</code></pre>\n<h2>2018-01-25</h2>\n<pre><code class=\"lang-\"># 实现注册逻辑\n# 写文章功能实现\n# 写文章时支持插入图片\n\n</code></pre>\n<h2>2018-01-26</h2>\n<pre><code class=\"lang-\"># 引入lodash工具类\n# 优化写文章的工具栏：滚动时固定顶部\n# 写文章 后台获取文章分类和标签\n\n# 首页的文章列表\n\n</code></pre>\n<h2>2018-01-27</h2>\n<pre><code class=\"lang-\"># 修改首页文章列表的样式\n# 首页加载文章功能\n# 文章查看功能\n# 文章分类和标签功能列表\n\n</code></pre>\n<h2>2018-01-28</h2>\n<pre><code class=\"lang-\"># 文章分类和标签详情\n\n</code></pre>\n<h2>2018-01-29</h2>\n<pre><code class=\"lang-\"># 文章分类和标签的文章数\n# 首页最热文章\n# 首页最新文章\n# 首页最热标签\n\n</code></pre>\n<h2>2018-01-30</h2>\n<pre><code class=\"lang-\"># BaseHeader放回views中\n# 修改Axios后置拦截，全局处理错误\n# 将登录 退出 和头像 放到一起\n\n</code></pre>\n', 1);
INSERT INTO `ms_article_body` VALUES (20, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。\n\n# 起步\n\n> 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。\n\n尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n```\n安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。\n\n# 声明式渲染\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n```javascript\n<div id=\"app\">\n  {{ message }}\n</div>\n\n```\n```javascript\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n\n```\n我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n\n除了文本插值，我们还可以像这样来绑定元素特性：\n\n\n\n\n\n\n', '<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br />\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>\n<h1>起步</h1>\n<blockquote>\n<p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>\n</blockquote>\n<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n</code></div></pre>\n<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p>\n<h1>声明式渲染</h1>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;div id=<span class=\"hljs-string\">\"app\"</span>&gt;\n  {{ message }}\n&lt;<span class=\"hljs-regexp\">/div&gt;\n\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n  }\n})\n\n</code></div></pre>\n<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性：</p>\n', 9);
INSERT INTO `ms_article_body` VALUES (21, '## 快速上手\n\n本节将介绍如何在项目中使用 Element。\n\n### 使用 Starter Kit\n我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。\n\n如果不希望使用我们提供的模板，请继续阅读。\n\n### 使用 vue-cli\n\n我们还可以使用 vue-cli 初始化项目，命令如下：\n\n```language\n> npm i -g vue-cli\n> mkdir my-project && cd my-project\n> vue init webpack\n> npm i && npm i element-ui\n```\n\n### 引入 Element\n你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。\n\n#### 完整引入\n在 main.js 中写入以下内容：\n```javascript\nimport Vue from \'vue\'\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nimport App from \'./App.vue\'\n\nVue.use(ElementUI)\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n})\n\n```\n以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。\n\n#### 按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n\n首先，安装 babel-plugin-component：\n\n', '<h2>快速上手</h2>\n<p>本节将介绍如何在项目中使用 Element。</p>\n<h3>使用 Starter Kit</h3>\n<p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p>\n<p>如果不希望使用我们提供的模板，请继续阅读。</p>\n<h3>使用 vue-cli</h3>\n<p>我们还可以使用 vue-cli 初始化项目，命令如下：</p>\n<pre><code class=\"lang-language\">&gt; npm i -g vue-cli\n&gt; mkdir my-project &amp;&amp; cd my-project\n&gt; vue init webpack\n&gt; npm i &amp;&amp; npm i element-ui\n</code></pre>\n<h3>引入 Element</h3>\n<p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p>\n<h4>完整引入</h4>\n<p>在 main.js 中写入以下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> ElementUI <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'element-ui\'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\'element-ui/lib/theme-chalk/index.css\'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./App.vue\'</span>\n\nVue.use(ElementUI)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =&gt;</span> h(App)\n})\n\n</code></div></pre>\n<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>\n<h4>按需引入</h4>\n<p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>\n<p>首先，安装 babel-plugin-component：</p>\n', 10);
INSERT INTO `ms_article_body` VALUES (1405564731351162882, '666666666666', '<p>666666666666</p>\n', 1405564731300831233);
INSERT INTO `ms_article_body` VALUES (1405909844828909569, '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image-20210523173712142](img/image-20210523173712142.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n![image-20210523174032053](img/image-20210523174032053.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image-20210523181737720](img/image-20210523181737720.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image-20210523182426404](img/image-20210523182426404.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', 1405909844724051969);
INSERT INTO `ms_article_body` VALUES (1405916999854342146, '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', 1405916999732707330);
INSERT INTO `ms_article_body` VALUES (1608050952940589058, '## 60天速成驾照\n```\nhhh\n开玩笑的啦 O(∩_∩)O哈哈~\n```', '<h2><a id=\"60_0\"></a>60天速成驾照</h2>\n<pre><code class=\"lang-\">hhh\n开玩笑的啦 O(∩_∩)O哈哈~\n</code></pre>\n', 1608050952827342850);
INSERT INTO `ms_article_body` VALUES (1662117613662142468, '# 软件需求说明书(GB856T-88)的结构\n## 1 引言\n	·1.1编写目的 \n	·1.2背景\n	·1.3定义\n	·1.4参考资料\n	\n## 2 任务概述\n\n	· 2.1目标\n	· 2.2用户的特点\n	· 2.3假定和约束\n	\n## 3 需求规定\n\n	·3.1对功能的规定 \n	·3.2对性能的规定 \n		·3.2.1精度\n		·3.2.2时间特性要求\n		·3.2.3灵活性\n	·3.3输人输出要求 \n	·3.4.数据管理能力要求\n	·3.5故障处理要求\n	·3.6基他专门要求\n	\n## 4 运行环境规定\n\n	·4.1设备\n	·4.2支持软件\n	·4.3接口 \n	·4.4控制\n		系统运行的流程图如下：(各种图：例如E-R图，DFD图，.......)', '<h1><a id=\"GB856T88_0\"></a>软件需求说明书(GB856T-88)的结构</h1>\n<h2><a id=\"1__1\"></a>1 引言</h2>\n<pre><code>·1.1编写目的 \n·1.2背景\n·1.3定义\n·1.4参考资料\n</code></pre>\n<h2><a id=\"2__7\"></a>2 任务概述</h2>\n<pre><code>· 2.1目标\n· 2.2用户的特点\n· 2.3假定和约束\n</code></pre>\n<h2><a id=\"3__13\"></a>3 需求规定</h2>\n<pre><code>·3.1对功能的规定 \n·3.2对性能的规定 \n	·3.2.1精度\n	·3.2.2时间特性要求\n	·3.2.3灵活性\n·3.3输人输出要求 \n·3.4.数据管理能力要求\n·3.5故障处理要求\n·3.6基他专门要求\n</code></pre>\n<h2><a id=\"4__25\"></a>4 运行环境规定</h2>\n<pre><code>·4.1设备\n·4.2支持软件\n·4.3接口 \n·4.4控制\n	系统运行的流程图如下：(各种图：例如E-R图，DFD图，.......)</code></pre>\n', 1662117613662142466);
INSERT INTO `ms_article_body` VALUES (1760583060224528387, '本篇题解只是记录我的做题过程代码，不提供最优解\n（另外这里所有的时间复杂度都只分析单个样例，不算$t$的时间复杂度）\n# A\n[点击此处查看对应的题目](https://atcoder.jp/contests/abc250/tasks/abc250_a).\n**本题设计算法：模拟**\n直接枚举所有点，判断是否与指定点的曼哈顿距离为 1。\n\n**时间复杂度 $O(r * c)$**\n```\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main()\n{\n    int r,c,x,y,res = 0;\n    cin >> r >> c >> x >> y;\n    for (int i = 1;i <= r;i ++ ) {\n        for (int j = 1;j <= c;j ++ ) {\n            if (abs(i - x) + abs(j - y) == 1) {\n                res ++;\n            }\n        }\n    }\n    cout << res << \'\\n\';\n    return 0;\n}\n\n\n```\n---\n# B\n[点击此处查看对应的题目](https://atcoder.jp/contests/abc250/tasks/abc250_b).\n**本题设计算法：模拟**\n\n通过观察可得我们可以把一个大方块划分为多个中方块，分别按中方块的次序交替输出即可，次序为偶数则里面的所有小方块输出点，次序为奇数则里面的所有小方块输出点 # 即可。\n\n**时间复杂度 $O(r * c * n^2)$**\n```\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1010;\nint n,r,c;\nchar g[N][N];\n\nvoid out(int id,int x,int y)\n{\n    for (int i = 1;i <= r;i ++) {\n        for (int j = 1;j <= c;j ++ ) {\n            if (!id) g[i + x * r][j + y * c] = \'.\';\n            else g[i + x * r][j + y * c] = \'#\';\n        }\n    }\n}\nint main()\n{\n    cin >> n >> r >> c;\n    int t = 0;\n    for (int i = 0;i < n;i ++ ) {\n        int x = t;\n        for (int j = 0;j < n;j ++ ) {\n            out(x,i,j);\n            x ^= 1;\n        }\n        t ^= 1;\n    }\n    for (int i = 1;i <= r * n;i ++,cout << \'\\n\') {\n        for (int j = 1;j <= c * n;j ++ ) {\n            cout << g[i][j];\n        }\n    }\n    return 0;\n}\n\n```\n---\n# C\n[点击此处查看对应的题目](https://atcoder.jp/contests/abc250/tasks/abc250_c).\n**本题设计算法：模拟 + map统计**\n\n我们可以开一个 map，记录一下所有说的下标，然后每次询问交换值和 map 所统计的下标即可。\n\n\n**时间复杂度 $O(n)$**\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\nconst int N = 2e5 + 10;\nint a[N];\n\nint main()\n{\n    int n,q;\n    cin >> n >> q;\n    \n    unordered_map<int,int> mp;\n    for (int i = 1;i <= n;i ++ ) { \n        a[i] = i;\n        mp[a[i]] = i;\n    }\n    while (q -- ) {\n        int x;\n        cin >> x;\n        if (mp.count(x)) {\n            int id = mp[x];\n            if (id == n) {\n                mp[a[id - 1]] = id;\n                mp[a[id]] = id - 1;\n                swap(a[id - 1],a[id]);\n            }else {\n                mp[a[id + 1]] = id;\n                mp[a[id]] = id + 1;\n                swap(a[id],a[id + 1]);\n            }\n        }\n    }\n\n    for (int i = 1;i <= n;i ++ ) cout << a[i] << \' \';\n    puts(\"\");\n    return 0;\n}\n\n```\n---\n# D\n[点击此处查看对应的题目](https://atcoder.jp/contests/abc250/tasks/abc250_d).\n**本题设计算法：质数筛 + 前缀和**\n\n由于题目要求 q *  q *  q * p <= 1e18 ，p < q ，且 q 都为质数。\n\n所以这题所有的  q 和 p 最多 1e6， 所以我们可以通过质数筛法 用大约 O(n) 的时间复杂度筛出所有小于或等于1e6 的所有的质数。\n\n由于p < q，所以每一个筛出的质数 q 都有 q - 1 或者 n / i / i / i 以内的质数的数量的 p (这里要取一下最小值)。\n\nnote ：取值的过程需要用到前缀和，这样就可以快速取出 x 以内的所有质数数量\n\n**时间复杂度 $O(N)$**\n\n```\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst ll N= 1000010;\nll primes[N], s[N], st[N], isp[N], cnt;\n\nvoid get_primes(ll n)\n{\n    for (int i = 2; i <= n; i ++ ) {\n        if (!st[i]) primes[cnt ++ ] = i,isp[i] = 1;\n        for (int j = 0; primes[j] <= n / i; j ++ ) {\n            st[primes[j] * i] = 1;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\nint main()\n{\n    ll n,res = 0,ans = 0;\n    cin >> n;\n    get_primes(N);\n    for (ll i = 2;i <= N;i ++ ) s[i] = s[i - 1] + isp[i];\n    for (ll i = 2;i <= N;i ++ ) {\n        if (isp[i]) {\n            res += s[min(n / i / i / i,i - 1)];\n        }\n    }\n    \n    cout << res << \'\\n\';\n    return 0;\n}\n\n```\n---\n# E\n[点击此处查看对应的题目](https://atcoder.jp/contests/abc250/tasks/abc250_e).\n**本题设计算法：序列哈希化 + 前缀和**\n\n用一个的唯一标识的随机数表示一个值，然后用一个hash数组，存入所有hash值，这样就可以 **快速判定** 两数组任意点的前缀是否相同(哈希前缀和相同即为前缀相同)。\n\nhash化的做法就是开一个随机数种子\n```\nsrand((unsigned long long)time(NULL));\n```\n\n**时间复杂度 $O(n)$**\n\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\nll a[N],b[N],ha[N],hb[N];\nunordered_map<ll,ll> hashmp;\nset<ll> sta,stb;\n\nint main()\n{\n    int n;\n    cin >> n;\n    srand((unsigned long long)time(NULL));\n    for (int i = 1;i <= n;i ++ ) scanf(\"%lld\",&a[i]);\n    for (int i = 1;i <= n;i ++ ) scanf(\"%lld\",&b[i]);\n    \n    for (int i = 1;i <= n;i ++ ) {\n        if (!hashmp.count(a[i])) hashmp[a[i]] = rand();\n        ha[i] = ha[i - 1];\n        if (!sta.count(a[i])) ha[i] += hashmp[a[i]];\n        sta.insert(a[i]);\n\n        if (!hashmp.count(b[i])) hashmp[b[i]] = rand();\n        hb[i] = hb[i - 1];\n        if (!stb.count(b[i])) hb[i] += hashmp[b[i]];\n        stb.insert(b[i]);\n    } \n\n    int q;\n    cin >> q;\n    while (q -- ) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        if (ha[x] == hb[y]) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n\n```\n', '<p>本篇题解只是记录我的做题过程代码，不提供最优解<br />\n（另外这里所有的时间复杂度都只分析单个样例，不算<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.61508em;\"></span><span class=\"strut bottom\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">t</span></span></span></span>的时间复杂度）</p>\n<h1><a id=\"A_2\"></a>A</h1>\n<p><a href=\"https://atcoder.jp/contests/abc250/tasks/abc250_a\" target=\"_blank\">点击此处查看对应的题目</a>.<br />\n<strong>本题设计算法：模拟</strong><br />\n直接枚举所有点，判断是否与指定点的曼哈顿距离为 1。</p>\n<p><strong>时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>r</mi><mo>∗</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(r * c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">c</span><span class=\"mclose\">)</span></span></span></span></strong></p>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main()\n{\n    int r,c,x,y,res = 0;\n    cin &gt;&gt; r &gt;&gt; c &gt;&gt; x &gt;&gt; y;\n    for (int i = 1;i &lt;= r;i ++ ) {\n        for (int j = 1;j &lt;= c;j ++ ) {\n            if (abs(i - x) + abs(j - y) == 1) {\n                res ++;\n            }\n        }\n    }\n    cout &lt;&lt; res &lt;&lt; \'\\n\';\n    return 0;\n}\n\n\n</code></pre>\n<hr />\n<h1><a id=\"B_36\"></a>B</h1>\n<p><a href=\"https://atcoder.jp/contests/abc250/tasks/abc250_b\" target=\"_blank\">点击此处查看对应的题目</a>.<br />\n<strong>本题设计算法：模拟</strong></p>\n<p>通过观察可得我们可以把一个大方块划分为多个中方块，分别按中方块的次序交替输出即可，次序为偶数则里面的所有小方块输出点，次序为奇数则里面的所有小方块输出点 # 即可。</p>\n<p><strong>时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>r</mi><mo>∗</mo><mi>c</mi><mo>∗</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(r * c * n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></strong></p>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1010;\nint n,r,c;\nchar g[N][N];\n\nvoid out(int id,int x,int y)\n{\n    for (int i = 1;i &lt;= r;i ++) {\n        for (int j = 1;j &lt;= c;j ++ ) {\n            if (!id) g[i + x * r][j + y * c] = \'.\';\n            else g[i + x * r][j + y * c] = \'#\';\n        }\n    }\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; r &gt;&gt; c;\n    int t = 0;\n    for (int i = 0;i &lt; n;i ++ ) {\n        int x = t;\n        for (int j = 0;j &lt; n;j ++ ) {\n            out(x,i,j);\n            x ^= 1;\n        }\n        t ^= 1;\n    }\n    for (int i = 1;i &lt;= r * n;i ++,cout &lt;&lt; \'\\n\') {\n        for (int j = 1;j &lt;= c * n;j ++ ) {\n            cout &lt;&lt; g[i][j];\n        }\n    }\n    return 0;\n}\n\n</code></pre>\n<hr />\n<h1><a id=\"C_86\"></a>C</h1>\n<p><a href=\"https://atcoder.jp/contests/abc250/tasks/abc250_c\" target=\"_blank\">点击此处查看对应的题目</a>.<br />\n<strong>本题设计算法：模拟 + map统计</strong></p>\n<p>我们可以开一个 map，记录一下所有说的下标，然后每次询问交换值和 map 所统计的下标即可。</p>\n<p><strong>时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></strong></p>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nconst int N = 2e5 + 10;\nint a[N];\n\nint main()\n{\n    int n,q;\n    cin &gt;&gt; n &gt;&gt; q;\n    \n    unordered_map&lt;int,int&gt; mp;\n    for (int i = 1;i &lt;= n;i ++ ) { \n        a[i] = i;\n        mp[a[i]] = i;\n    }\n    while (q -- ) {\n        int x;\n        cin &gt;&gt; x;\n        if (mp.count(x)) {\n            int id = mp[x];\n            if (id == n) {\n                mp[a[id - 1]] = id;\n                mp[a[id]] = id - 1;\n                swap(a[id - 1],a[id]);\n            }else {\n                mp[a[id + 1]] = id;\n                mp[a[id]] = id + 1;\n                swap(a[id],a[id + 1]);\n            }\n        }\n    }\n\n    for (int i = 1;i &lt;= n;i ++ ) cout &lt;&lt; a[i] &lt;&lt; \' \';\n    puts(&quot;&quot;);\n    return 0;\n}\n\n</code></pre>\n<hr />\n<h1><a id=\"D_137\"></a>D</h1>\n<p><a href=\"https://atcoder.jp/contests/abc250/tasks/abc250_d\" target=\"_blank\">点击此处查看对应的题目</a>.<br />\n<strong>本题设计算法：质数筛 + 前缀和</strong></p>\n<p>由于题目要求 q *  q *  q * p &lt;= 1e18 ，p &lt; q ，且 q 都为质数。</p>\n<p>所以这题所有的  q 和 p 最多 1e6， 所以我们可以通过质数筛法 用大约 O(n) 的时间复杂度筛出所有小于或等于1e6 的所有的质数。</p>\n<p>由于p &lt; q，所以每一个筛出的质数 q 都有 q - 1 或者 n / i / i / i 以内的质数的数量的 p (这里要取一下最小值)。</p>\n<p>note ：取值的过程需要用到前缀和，这样就可以快速取出 x 以内的所有质数数量</p>\n<p><strong>时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></strong></p>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll N= 1000010;\nll primes[N], s[N], st[N], isp[N], cnt;\n\nvoid get_primes(ll n)\n{\n    for (int i = 2; i &lt;= n; i ++ ) {\n        if (!st[i]) primes[cnt ++ ] = i,isp[i] = 1;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ ) {\n            st[primes[j] * i] = 1;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\nint main()\n{\n    ll n,res = 0,ans = 0;\n    cin &gt;&gt; n;\n    get_primes(N);\n    for (ll i = 2;i &lt;= N;i ++ ) s[i] = s[i - 1] + isp[i];\n    for (ll i = 2;i &lt;= N;i ++ ) {\n        if (isp[i]) {\n            res += s[min(n / i / i / i,i - 1)];\n        }\n    }\n    \n    cout &lt;&lt; res &lt;&lt; \'\\n\';\n    return 0;\n}\n\n</code></pre>\n<hr />\n<h1><a id=\"E_191\"></a>E</h1>\n<p><a href=\"https://atcoder.jp/contests/abc250/tasks/abc250_e\" target=\"_blank\">点击此处查看对应的题目</a>.<br />\n<strong>本题设计算法：序列哈希化 + 前缀和</strong></p>\n<p>用一个的唯一标识的随机数表示一个值，然后用一个hash数组，存入所有hash值，这样就可以 <strong>快速判定</strong> 两数组任意点的前缀是否相同(哈希前缀和相同即为前缀相同)。</p>\n<p>hash化的做法就是开一个随机数种子</p>\n<pre><code class=\"lang-\">srand((unsigned long long)time(NULL));\n</code></pre>\n<p><strong>时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></strong></p>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n#include &lt;ctime&gt;\n#include &lt;set&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\nll a[N],b[N],ha[N],hb[N];\nunordered_map&lt;ll,ll&gt; hashmp;\nset&lt;ll&gt; sta,stb;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    srand((unsigned long long)time(NULL));\n    for (int i = 1;i &lt;= n;i ++ ) scanf(&quot;%lld&quot;,&amp;a[i]);\n    for (int i = 1;i &lt;= n;i ++ ) scanf(&quot;%lld&quot;,&amp;b[i]);\n    \n    for (int i = 1;i &lt;= n;i ++ ) {\n        if (!hashmp.count(a[i])) hashmp[a[i]] = rand();\n        ha[i] = ha[i - 1];\n        if (!sta.count(a[i])) ha[i] += hashmp[a[i]];\n        sta.insert(a[i]);\n\n        if (!hashmp.count(b[i])) hashmp[b[i]] = rand();\n        hb[i] = hb[i - 1];\n        if (!stb.count(b[i])) hb[i] += hashmp[b[i]];\n        stb.insert(b[i]);\n    } \n\n    int q;\n    cin &gt;&gt; q;\n    while (q -- ) {\n        int x,y;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        if (ha[x] == hb[y]) puts(&quot;Yes&quot;);\n        else puts(&quot;No&quot;);\n    }\n    return 0;\n}\n\n</code></pre>\n', 1760583060186779650);
INSERT INTO `ms_article_body` VALUES (1760687849461526530, '[原题链接](https://www.acwing.com/problem/content/description/168/)\n---\n\n数独是一种传统益智游戏，你需要把一个 $9 \\\\times 9$ 的数独补充完整，使得数独中每行、每列、每个 $3 \\\\times 3$ 的九宫格内数字 $1 \\\\sim 9$ 均恰好出现一次。\n\n请编写一个程序填写数独。\n\n#### 输入格式\n\n输入包含多组测试用例。\n\n每个测试用例占一行，包含 $81$ 个字符，代表数独的 $81$ 个格内数据（顺序总体由上到下，同行由左到右）。\n\n每个字符都是一个数字（$1-9$）或一个 `.`（表示尚未填充）。\n\n您可以假设输入中的每个谜题都只有一个解决方案。\n\n文件结尾处为包含单词 `end` 的单行，表示输入结束。\n\n#### 输出格式\n\n每个测试用例，输出一行数据，代表填充完全后的数独。\n\n#### 输入样例：\n\n    4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\n    ......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.\n    end\n    \n\n#### 输出样例：\n\n    417369825632158947958724316825437169791586432346912758289643571573291684164875293\n    416837529982465371735129468571298643293746185864351297647913852359682714128574936\n    \n\n---\n### 算法\n##### (dfs)  \n### 剪枝与优化：\n\n- 位运算优化：在这一个问题里，位运算可以快速的帮助我们去判断一个行，列，宫里是否存在一个和它相同的数。\n\n- 可行性剪枝：我们先看一下这一个格子填在这里，是不是在所在的行，所在的列，所在的宫里都没有出现过。\n\n- 最优性剪枝：我们可以随意选择一个空格子。假设我们枚举到了两个格子，有一个格子有 99 种填法，有一个格子有两种填法，那么我们应该先去选择填法较少的那一个格子\n\n\n---\n另外这里 dfs 用 bool 型的好处就是可以找到一个解后一路 return 掉\n\n#### C++ 代码\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 9,M = 1 << N;\nint ones[M],map[M];//分别代表有多少个 1 和打表数组 \nint row[N],col[N],cell[3][3];\nchar str[N * N];\n\n#define lowbit(x) (x & -x) \nvoid init()// 初始化(将所有位置都初始化可以填数的状态)\n{\n    for (int i = 0;i < N;i ++ ) row[i] = col[i] = (1 << N) - 1;\n    for (int i = 0;i < 3;i ++ ) \n        for (int j = 0;j < 3;j ++ ) \n            cell[i][j] = (1 << N) - 1;// 每个3 * 3的小方格也用二进制来优化(刚开始也都为1)\n}\nvoid draw(int x,int y,int t,bool is_set) // 在(x, y)的位置上(is_set)<是/否>填t的操作 \n{\n    if (is_set) str[x * N + y] = t + \'1\';\n    else str[x * N + y] = \'.\';\n    \n    int v = 1 << t;// 找到该数对应二进制之后的位置的数\n    if (!is_set) v = -v;//不填的话加回来，以保持原样\n    row[x] -= v;\n    col[y] -= v;\n    cell[x / 3][y / 3] -= v;\n}\nint get(int x,int y)\n{\n    return row[x] & col[y] & cell[x / 3][y / 3];\n}\nbool dfs(int u)\n{\n    if (!u) return true;\n    int x,y,minv = 10;// x, y记录枚举方案最少的位置的x, y,记录当前最少枚举方案\n\n    for (int i = 0;i < N;i ++ ) {\n        for (int j = 0;j < N;j ++ ) {\n            if (str[i * N + j] == \'.\') {\n                int state = get(i,j);// 找到该位置上能填的数的状态\n                if (ones[state] < minv) {\n                    x = i,y = j;\n                    minv = ones[state];\n                }\n            }\n        }\n    }\n    int state = get(x,y);// 找到最少枚举方案对应的位置的能填的数的状态\n    for (int i = state;i;i -= lowbit(i)) {\n        int t = map[lowbit(i)];\n        draw(x,y,t,true);// 找到该位置上能填的数\n        if (dfs(u - 1)) return true; // 如果找到一组可行解就一路return true下去\n        draw(x,y,t,false);\n    }\n    return false;\n}\nint main()\n{\n    for (int i = 0;i < N;i ++ ) map[1 << i] = i;//预处理每个以二为底的数有多少\n    for (int i = 0;i < 1 << N;i ++ ) {\n        for (int j = 0;j < N;j ++ ) {\n            ones[i] += i >> j & 1;//每个数的二进制表示有多少个1\n        }\n    }\n\n    while (cin >> str && str[0] != \'e\') {\n        init();\n\n        int cnt = 0;// 记录有几个空格需要填数\n        for (int i = 0,k = 0;i < N;i ++ ) {\n            for (int j = 0;j < N;j ++,k ++ ) {\n                if (str[k] != \'.\') {//不需要填数\n                    int t = str[k] - \'1\';\n                    draw(i,j,t,true);\n                }else cnt ++;\n            }\n        }\n        dfs(cnt);\n        puts(str);\n    }\n    return 0;\n}\n```', '<h2><a id=\"httpswwwacwingcomproblemcontentdescription168_0\"></a><a href=\"https://www.acwing.com/problem/content/description/168/\" target=\"_blank\">原题链接</a></h2>\n<p>数独是一种传统益智游戏，你需要把一个 9 \\\\times 9 的数独补充完整，使得数独中每行、每列、每个 3 \\\\times 3 的九宫格内数字 1 \\\\sim 9 均恰好出现一次。</p>\n<p>请编写一个程序填写数独。</p>\n<h4><a id=\"_7\"></a>输入格式</h4>\n<p>输入包含多组测试用例。</p>\n<p>每个测试用例占一行，包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>8</mn><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">81</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathrm\">8</span><span class=\"mord mathrm\">1</span></span></span></span> 个字符，代表数独的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>8</mn><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">81</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathrm\">8</span><span class=\"mord mathrm\">1</span></span></span></span> 个格内数据（顺序总体由上到下，同行由左到右）。</p>\n<p>每个字符都是一个数字（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>−</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">1-9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathrm\">1</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">9</span></span></span></span>）或一个 <code>.</code>（表示尚未填充）。</p>\n<p>您可以假设输入中的每个谜题都只有一个解决方案。</p>\n<p>文件结尾处为包含单词 <code>end</code> 的单行，表示输入结束。</p>\n<h4><a id=\"_19\"></a>输出格式</h4>\n<p>每个测试用例，输出一行数据，代表填充完全后的数独。</p>\n<h4><a id=\"_23\"></a>输入样例：</h4>\n<pre><code>4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\n......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.\nend\n</code></pre>\n<h4><a id=\"_30\"></a>输出样例：</h4>\n<pre><code>417369825632158947958724316825437169791586432346912758289643571573291684164875293\n416837529982465371735129468571298643293746185864351297647913852359682714128574936\n</code></pre>\n<hr />\n<h3><a id=\"_37\"></a>算法</h3>\n<h5><a id=\"dfs_38\"></a>(dfs)</h5>\n<h3><a id=\"_39\"></a>剪枝与优化：</h3>\n<ul>\n<li>\n<p>位运算优化：在这一个问题里，位运算可以快速的帮助我们去判断一个行，列，宫里是否存在一个和它相同的数。</p>\n</li>\n<li>\n<p>可行性剪枝：我们先看一下这一个格子填在这里，是不是在所在的行，所在的列，所在的宫里都没有出现过。</p>\n</li>\n<li>\n<p>最优性剪枝：我们可以随意选择一个空格子。假设我们枚举到了两个格子，有一个格子有 99 种填法，有一个格子有两种填法，那么我们应该先去选择填法较少的那一个格子</p>\n</li>\n</ul>\n<hr />\n<p>另外这里 dfs 用 bool 型的好处就是可以找到一个解后一路 return 掉</p>\n<h4><a id=\"C__51\"></a>C++ 代码</h4>\n<pre><code class=\"lang-\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 9,M = 1 &lt;&lt; N;\nint ones[M],map[M];//分别代表有多少个 1 和打表数组 \nint row[N],col[N],cell[3][3];\nchar str[N * N];\n\n#define lowbit(x) (x &amp; -x) \nvoid init()// 初始化(将所有位置都初始化可以填数的状态)\n{\n    for (int i = 0;i &lt; N;i ++ ) row[i] = col[i] = (1 &lt;&lt; N) - 1;\n    for (int i = 0;i &lt; 3;i ++ ) \n        for (int j = 0;j &lt; 3;j ++ ) \n            cell[i][j] = (1 &lt;&lt; N) - 1;// 每个3 * 3的小方格也用二进制来优化(刚开始也都为1)\n}\nvoid draw(int x,int y,int t,bool is_set) // 在(x, y)的位置上(is_set)&lt;是/否&gt;填t的操作 \n{\n    if (is_set) str[x * N + y] = t + \'1\';\n    else str[x * N + y] = \'.\';\n    \n    int v = 1 &lt;&lt; t;// 找到该数对应二进制之后的位置的数\n    if (!is_set) v = -v;//不填的话加回来，以保持原样\n    row[x] -= v;\n    col[y] -= v;\n    cell[x / 3][y / 3] -= v;\n}\nint get(int x,int y)\n{\n    return row[x] &amp; col[y] &amp; cell[x / 3][y / 3];\n}\nbool dfs(int u)\n{\n    if (!u) return true;\n    int x,y,minv = 10;// x, y记录枚举方案最少的位置的x, y,记录当前最少枚举方案\n\n    for (int i = 0;i &lt; N;i ++ ) {\n        for (int j = 0;j &lt; N;j ++ ) {\n            if (str[i * N + j] == \'.\') {\n                int state = get(i,j);// 找到该位置上能填的数的状态\n                if (ones[state] &lt; minv) {\n                    x = i,y = j;\n                    minv = ones[state];\n                }\n            }\n        }\n    }\n    int state = get(x,y);// 找到最少枚举方案对应的位置的能填的数的状态\n    for (int i = state;i;i -= lowbit(i)) {\n        int t = map[lowbit(i)];\n        draw(x,y,t,true);// 找到该位置上能填的数\n        if (dfs(u - 1)) return true; // 如果找到一组可行解就一路return true下去\n        draw(x,y,t,false);\n    }\n    return false;\n}\nint main()\n{\n    for (int i = 0;i &lt; N;i ++ ) map[1 &lt;&lt; i] = i;//预处理每个以二为底的数有多少\n    for (int i = 0;i &lt; 1 &lt;&lt; N;i ++ ) {\n        for (int j = 0;j &lt; N;j ++ ) {\n            ones[i] += i &gt;&gt; j &amp; 1;//每个数的二进制表示有多少个1\n        }\n    }\n\n    while (cin &gt;&gt; str &amp;&amp; str[0] != \'e\') {\n        init();\n\n        int cnt = 0;// 记录有几个空格需要填数\n        for (int i = 0,k = 0;i &lt; N;i ++ ) {\n            for (int j = 0;j &lt; N;j ++,k ++ ) {\n                if (str[k] != \'.\') {//不需要填数\n                    int t = str[k] - \'1\';\n                    draw(i,j,t,true);\n                }else cnt ++;\n            }\n        }\n        dfs(cnt);\n        puts(str);\n    }\n    return 0;\n}\n</code></pre>\n', 1760687849444749313);
INSERT INTO `ms_article_body` VALUES (1761384609020411905, '阿达是的15616516515', '<p>阿达是的15616516515</p>\n', 1761384608915554306);
INSERT INTO `ms_article_body` VALUES (1770444117457788930, '# 1. SpringAOP的基本概念\n\nSpringAOP（Aspect-Oriented Programming）即面向切面编程，是Spring框架体系中非常重要的功能模块之一。AOP与OOP（面向对象编程）相辅相成，提供了一种与OOP不同的抽象软件结构的视图。\n\n在OOP中，程序的基本单元是类，而AOP的基本单元是Aspect（切面），切面能够对那些影响多个类的公共行为进行封装。这种“横切”的技术，将封装对象内部剖解开，将那些影响多个类的公共方法封装到一个可重用的模块中，从而减少系统的重复代码，降低模块间的耦合度，提高系统的可操作性和可维护性。\n\nAOP采取横向抽取机制，取代了传统纵向继承体系中的重复性代码。在业务处理代码中，如日志记录、性能统计、安全控制、事务处理、异常处理等操作，尽管使用OOP可以通过封装或继承的方式达到代码的重用，但仍然有相同的代码分散在各个方法中。而AOP则能够将这些操作封装到独立的模块中，使关注点代码与业务代码分离，从而简化了程序结构，提高了代码的可读性和可维护性。\n\nAOP中的关键概念包括：\n\n1. Joinpoint（连接点）：类中可以被增强的方法。\n2. Pointcut（切入点）：实际被增强的方法，即在类中可以有很多方法被增强，但实际被增强的方法被称为切入点。\n3. Advice（通知/增强）：增强的逻辑，即具体的切面逻辑代码。\n\n总的来说，SpringAOP通过面向切面编程的方式，提供了一种灵活且强大的机制，用于处理那些跨越多个类和方法的公共行为，从而提高了软件系统的可维护性和可扩展性。\n\nAOP中的关键概念包括：\n\nJoinpoint（连接点）：类中可以被增强的方法。\n\nPointcut（切入点）：实际被增强的方法，即在类中可以有很多方法被增强，但实际被增强的方法被称为切入点。\n\nAdvice（通知/增强）：增强的逻辑，即具体的切面逻辑代码。\n\n总的来说，SpringAOP通过面向切面编程的方式，提供了一种灵活且强大的机制，用于处理那些跨越多个类和方法的公共行为，从而提高了软件系统的可维护性和可扩展性。\n\n# 2.AOP代码执行顺序\n在Spring AOP（Aspect-Oriented Programming）中，当使用环绕通知（Around Advice）时，代码的执行顺序遵循以下逻辑：\n\n1. **前置通知（Before Advice）**: 如果定义了前置通知，它会在目标方法执行之前被调用。前置通知主要用于执行一些准备性的工作，比如开启事务、设置参数等。\n\n2. **环绕通知（Around Advice）开始**: 环绕通知是AOP中最强大的通知类型，因为它允许你在目标方法执行前后进行自定义的逻辑处理。当目标方法被调用时，环绕通知的逻辑开始执行。\n\n3. **环绕通知内部逻辑**: 在环绕通知中，你可以决定是否继续执行目标方法，以及何时执行。这通过`ProceedingJoinPoint`的`proceed()`方法来实现。如果你希望在目标方法执行前做一些处理，可以在调用`proceed()`之前完成；如果需要在目标方法执行后做处理，可以在`proceed()`之后完成。\n\n4. **目标方法执行**: 当环绕通知中的`proceed()`方法被调用时，目标方法开始执行。这是实际业务逻辑的部分。\n\n5. **环绕通知后续逻辑**: 在目标方法执行完毕后，环绕通知的后续逻辑将执行。这通常包括一些清理工作，比如关闭资源、提交或回滚事务等。\n\n6. **后置通知（After Advice）**: 如果定义了后置通知，它会在目标方法执行之后（无论目标方法是否成功执行）被调用。后置通知通常用于执行一些清理或日志记录工作。\n\n7. **异常通知（After Throwing Advice）**: 如果目标方法抛出了异常，并且定义了异常通知，那么异常通知将在异常被抛出后执行。这允许你执行一些特定的异常处理逻辑。\n\n8. **返回通知（After Returning Advice）**: 如果定义了返回通知，并且目标方法成功返回了结果，那么返回通知将在目标方法返回结果之后执行。这通常用于处理方法的返回值。\n\n>总结来说，Spring AOP中的代码执行顺序是：前置通知 -> 环绕通知开始 -> 目标方法执行 -> 环绕通知后续逻辑 -> 后置通知/异常通知/返回通知。\n\n>注意：以上顺序基于Spring AOP的默认行为，但可以通过配置或编程方式改变通知的执行顺序。\n\n\n\n# 3. SpringAop常用注解\nSpring AOP（Aspect-Oriented Programming）常用的注解包括：\n\n1. `@Aspect`: 该注解用于声明一个类为切面类，即这个类将包含一些通知（Advice）和切入点（Pointcut）的定义。\n\n2. `@Pointcut`: 该注解用于定义一个切入点，切入点是一个表达式，它指定了在哪些方法执行时要应用通知。切入点表达式通常基于方法签名、异常类型、注解等来定义匹配规则。\n\n3. `@Before`: 该注解用于定义前置通知（Before Advice），即目标方法执行之前的通知。前置通知常用于执行一些准备性的工作，如设置参数、开启事务、申请资源等。\n\n4. `@After`: 该注解用于定义后置通知（After Advice），即目标方法执行之后的通知。后置通知常用于执行一些清理工作，如关闭资源、记录日志等。\n\n5. `@AfterReturning`: 该注解用于定义返回后通知（After Returning Advice），即目标方法正常返回之后的通知。这个通知可以获取到目标方法的返回值，并进行相应的处理。\n\n6. `@AfterThrowing`: 该注解用于定义异常后通知（After Throwing Advice），即目标方法抛出异常之后的通知。这个通知可以在异常处理逻辑中发挥作用，如记录异常信息、进行回滚操作等。\n\n7. `@Around`: 该注解用于定义环绕通知（Around Advice），即在目标方法执行前后都进行通知。环绕通知可以控制目标方法的执行流程，如是否执行目标方法、何时执行目标方法等。\n\n为了使Spring AOP生效，你还需要在Spring配置中启用AspectJ自动代理，这通常通过在配置类上添加`@EnableAspectJAutoProxy`注解来实现。同时，你还需要确保切面类被Spring容器管理，通常通过在切面类上添加`@Component`注解来实现。\n\n# 4. 另外举几个例子说明\n## @Aspect\n`@Aspect` 是 Spring AOP（Aspect-Oriented Programming）中的一个关键注解，用于定义一个切面（Aspect）。切面是 AOP 的核心概念之一，它代表了横切关注点（cross-cutting concerns）的模块化实现。这些关注点通常包括日志记录、事务管理、权限验证等，它们跨越多个应用层次和多个类，因此不适合直接放在业务逻辑代码中。\n\n`@Aspect` 注解通常标注在一个类上，该类随后会被 Spring 容器识别为一个切面类，并且其中的通知（Advice）和切入点（Pointcut）会被容器自动处理。切面类可以包含多种类型的通知，如前置通知（`@Before`）、后置通知（`@After`）、返回后通知（`@AfterReturning`）、异常后通知（`@AfterThrowing`）以及环绕通知（`@Around`）。\n\n下面是一个简单的例子，展示了如何使用 `@Aspect` 注解定义一个切面类：\n\n```java\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    // 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    // 使用 @Before 注解定义一个前置通知\n    @Before(\"serviceMethods()\")\n    public void logBefore() {\n        System.out.println(\"Method is being called\");\n        // 在这里可以添加日志记录的逻辑\n    }\n\n    // 其他通知方法...\n}\n```\n\n在这个例子中，`LoggingAspect` 类被标注为 `@Aspect`，意味着它是一个切面类。该类定义了一个切入点 `serviceMethods()`，它匹配 `com.example.service` 包下所有类的所有方法。然后，使用 `@Before` 注解定义了一个前置通知 `logBefore()`，该通知会在匹配切入点的方法执行之前执行。\n\n要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，这通常通过在配置类上添加 `@EnableAspectJAutoProxy` 注解来实现。此外，确保切面类被 Spring 容器管理，通常通过在类上添加 `@Component` 注解来实现。这样，当目标方法被调用时，相应的通知就会根据切入点的规则被触发执行。\n\n## @Pointcut\n在Spring AOP（Aspect-Oriented Programming）中，`@Pointcut`是一个注解，用于定义一个切入点（Pointcut）。切入点是一个表达式，它指定了在哪些方法执行时要应用通知（Advice）。简而言之，`@Pointcut`注解允许你定义一个规则，当这个规则匹配时，相应的通知（如前置通知、后置通知、异常通知等）就会被触发。\n\n`@Pointcut`注解通常定义在一个方法上，这个方法没有返回类型，并且通常没有方法体（或者方法体为空）。这个方法的名称代表了切入点的名称，而方法的参数则是一个切入点表达式，用于指定哪些方法匹配该切入点。\n\n切入点表达式通常使用AspectJ的表达式语言编写，可以基于方法签名（如方法名、参数类型、返回类型等）、异常类型、注解等来定义匹配规则。\n\n下面是一个简单的例子，展示了如何使用`@Pointcut`注解来定义一个切入点：\n\n```java\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.annotation.Aspect;\n\n@Aspect\npublic class MyAspect {\n\n    // 定义一个切入点，匹配com.example.service包下所有类的所有方法\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {\n        // 方法体为空，因为@Pointcut注解定义的是一个切入点规则，而不是具体的业务逻辑\n    }\n\n    // 其他通知（Advice）可以使用这个切入点\n    // ...\n}\n```\n\n在这个例子中，`serviceMethods`方法定义了一个切入点，它匹配`com.example.service`包下所有类的所有方法。之后，你可以在其他通知方法中使用`serviceMethods()`作为切入点表达式，来指定这些通知应该在哪些方法执行时应用。\n\n`@Pointcut`注解使得切入点定义更加集中和易于管理，你可以在同一个Aspect类中定义多个切入点，然后在不同的通知中重复使用这些切入点。这有助于提高代码的可读性和可维护性。\n## @Before\n在Spring AOP（Aspect-Oriented Programming）中，`@Before`注解用于定义前置通知（Before Advice）。前置通知在目标方法执行之前执行，通常用于执行一些准备性的工作，如设置参数、开启事务、申请资源等。\n\n使用`@Before`注解的方法通常会接收一个`JoinPoint`参数，它代表了一个连接点（即一个方法的执行）。你可以通过这个参数获取关于目标方法的信息，如方法名、参数等。\n\n下面是一个使用`@Before`注解的示例：\n\n```java\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class MyAspect {\n\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void logBeforeMethod(JoinPoint joinPoint) {\n        System.out.println(\"About to execute method: \" + joinPoint.getSignature().getName());\n        // 这里可以添加一些准备性的工作，如开启事务、申请资源等\n    }\n}\n```\n\n在这个示例中，`@Before`注解定义了一个前置通知`logBeforeMethod`，它会在`com.example.service`包下所有类的所有方法执行之前执行。通知方法接收一个`JoinPoint`参数，允许你获取关于即将执行的方法的信息。\n\n前置通知通常用于执行一些与目标方法执行相关的前置条件检查或资源准备工作。例如，你可能需要在执行数据库操作之前开启事务，或者在调用某个服务之前申请必要的资源。\n\n请注意，`@Before`注解的切入点表达式决定了哪些方法执行前会触发这个通知。在上面的示例中，切入点表达式`execution(* com.example.service.*.*(..))`意味着所有在`com.example.service`包下的类的所有方法执行前都会触发这个通知。\n\n最后，和`@After`注解一样，你需要在Spring配置中启用AspectJ自动代理，以便Spring能够识别和处理这些方面（Aspects）。这通常通过在配置类上添加`@EnableAspectJAutoProxy`注解来实现。\n\n\n\n## @After\n在Spring AOP（Aspect-Oriented Programming）中，`@After`注解用于定义后置通知（After Advice）。后置通知在目标方法执行完毕之后执行，无论目标方法是否成功完成（即无论是否抛出异常）。这意味着，即使目标方法抛出异常，后置通知也会被触发。\n\n使用`@After`注解的方法通常会接收一个`JoinPoint`参数，它代表了一个连接点（即一个方法的执行）。然而，`@After`通知通常不需要这个参数，因为它是在目标方法执行完毕之后运行的，此时你已经无法影响目标方法的执行了。\n\n下面是一个使用`@After`注解的示例：\n\n```java\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    @After(\"execution(* com.example.service.*.*(..))\")\n    public void logAfterMethod() {\n        System.out.println(\"Method has been executed.\");\n    }\n}\n```\n\n在这个示例中，`@After`注解定义了一个后置通知`logAfterMethod`，它会在`com.example.service`包下所有类的所有方法执行完毕后执行。通知方法没有接收任何参数，因为它只是简单地打印一条消息，表明方法已经执行完毕。\n\n请注意，`@After`注解的切入点表达式决定了哪些方法执行后会触发这个通知。在上面的示例中，切入点表达式`execution(* com.example.service.*.*(..))`意味着所有在`com.example.service`包下的类的所有方法执行后都会触发这个通知。\n\n后置通知通常用于执行一些清理工作、日志记录或监视任务，这些任务需要在方法执行后但不需要考虑方法是否成功执行的情况下执行。\n\n最后，请记住要在Spring配置中启用AspectJ自动代理，以便Spring能够识别和处理这些方面（Aspects）。这通常通过在配置类上添加`@EnableAspectJAutoProxy`注解来实现。\n\n## @AfterReturning\n\n`@AfterReturning` 是 Spring AOP（Aspect-Oriented Programming）中的一个注解，用于定义一个返回后通知（After Returning Advice）。这种通知会在被切点方法正常执行并返回之后执行，它允许你访问到被切点方法的返回值，并根据这个返回值进行一些后续的处理操作。\n\n这个注解通常用于执行一些在方法执行成功后的逻辑，比如根据方法的返回结果更新某些状态、记录日志、发送通知等。\n\n`@AfterReturning` 注解有几个重要的属性：\n\n- `pointcut` 或 `value`：用于指定切入点表达式，确定哪些方法的执行会触发这个通知。\n- `returning`：指定一个参数名，这个参数会接收被切点方法的返回值，你可以在通知方法中通过这个参数访问到返回值。\n\n下面是一个使用 `@AfterReturning` 的例子：\n\n```java\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    // 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    // 使用 @AfterReturning 注解定义一个返回后通知\n    @AfterReturning(pointcut = \"serviceMethods()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        System.out.println(\"Method executed successfully: \" + joinPoint.getSignature().getName());\n        System.out.println(\"Returned value: \" + result);\n        // 在这里可以根据返回值进行一些处理，比如记录日志、更新状态等\n    }\n}\n```\n\n在这个例子中，`logAfterReturning` 方法是一个返回后通知，它会在 `serviceMethods()` 切入点匹配的方法成功执行后执行。通过 `returning = \"result\"` 指定了一个参数名 `result`，这个参数会接收被切点方法的返回值，然后在通知方法中打印出来。\n\n要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，并确保切面类被 Spring 容器管理。这样，当目标方法成功执行并返回后，相应的返回后通知就会根据切入点的规则被触发执行。\n\n## @AfterThrowing\n\n`@AfterThrowing` 是 Spring AOP（Aspect-Oriented Programming）中的一个注解，用于定义一个异常后通知（After Throwing Advice）。这个通知在被切点方法抛出异常时执行，允许你在方法发生异常时执行一些逻辑，如记录异常信息、进行清理工作、回滚事务等。\n\n`@AfterThrowing` 注解有几个重要的属性：\n\n- `pointcut` 或 `value`：用于指定切入点表达式，确定哪些方法的异常会触发这个通知。\n- `throwing`：指定一个参数名，该参数将接收被切点方法抛出的异常对象，允许你在通知方法中访问并处理这个异常。\n\n下面是一个使用 `@AfterThrowing` 的例子：\n\n```java\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.AfterThrowing;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class ExceptionHandlingAspect {\n\n    // 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    // 使用 @AfterThrowing 注解定义一个异常后通知\n    @AfterThrowing(pointcut = \"serviceMethods()\", throwing = \"ex\")\n    public void handleException(JoinPoint joinPoint, Throwable ex) {\n        System.out.println(\"Method failed: \" + joinPoint.getSignature().getName());\n        System.out.println(\"Thrown exception: \" + ex.getMessage());\n        // 在这里可以记录异常信息、进行清理工作、回滚事务等\n    }\n}\n```\n\n在这个例子中，`handleException` 方法是一个异常后通知，它会在 `serviceMethods()` 切入点匹配的方法抛出异常时执行。通过 `throwing = \"ex\"` 指定了一个参数名 `ex`，这个参数会接收被切点方法抛出的异常对象，然后在通知方法中打印出异常信息。\n\n要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，并确保切面类被 Spring 容器管理。这样，当目标方法抛出异常时，相应的异常后通知就会根据切入点的规则被触发执行。\n\n通过结合使用 `@Pointcut` 来定义复用的切入点表达式，你可以使通知的定义更加简洁和可维护。同时，Spring AOP 还支持其他类型的通知，如 `@Before`（前置通知）、`@After`（后置通知）和 `@Around`（环绕通知），它们提供了在方法执行的不同阶段执行自定义逻辑的能力。\n\n## @Around\n在Spring AOP中，@Around注解用于定义环绕通知（Around Advice），它是最强大的一种通知类型，因为它允许你在目标方法执行前后进行自定义的逻辑处理，并且可以决定是否继续执行目标方法以及何时执行。\n\n当你使用@Around注解时，你需要定义一个方法，这个方法将接收一个ProceedingJoinPoint参数，这个参数代表了被通知方法的执行点。你可以在这个方法内部实现自己的逻辑，比如前置处理、后置处理、异常处理等。\n\n下面是一个使用@Around注解的示例：\n```\nimport org.aspectj.lang.ProceedingJoinPoint;  \nimport org.aspectj.lang.annotation.Around;  \nimport org.aspectj.lang.annotation.Aspect;  \nimport org.springframework.stereotype.Component;  \n  \n@Aspect  \n@Component  \npublic class MyAspect {  \n  \n    @Around(\"execution(* com.example.service.*.*(..))\")  \n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {  \n        long start = System.currentTimeMillis();  \n  \n        Object proceed = joinPoint.proceed(); // 继续执行目标方法  \n  \n        long executionTime = System.currentTimeMillis() - start;  \n  \n        System.out.println(joinPoint.getSignature() + \" executed in \" + executionTime + \"ms\");  \n  \n        return proceed;  \n    }  \n}\n```\n在这个示例中，@Around注解用于定义一个环绕通知，它会在com.example.service包下所有类的所有方法执行前后起作用。通知方法logExecutionTime接收一个ProceedingJoinPoint参数，允许你在执行目标方法之前和之后插入自定义逻辑。\n\n在logExecutionTime方法中：\n\n记录方法开始执行的时间。\n调用proceed()方法执行目标方法。\n记录方法执行结束的时间，并计算执行时长。\n打印方法的执行时长。\n如果proceed()方法没有被调用，那么目标方法将不会被执行。这意味着你可以在环绕通知中根据某些条件决定是否继续执行目标方法。\n\n请注意，为了使用@Around注解，你需要在Spring配置中启用AspectJ自动代理，这通常通过在配置类上添加@EnableAspectJAutoProxy注解来实现。\n\n此外，@Around注解中的切入点表达式（Pointcut Expression）决定了哪些方法会被这个通知所影响。在上面的示例中，切入点表达式execution(* com.example.service.*.*(..))意味着所有在com.example.service包下的类的所有方法都会被这个通知所影响。你可以根据需要调整切入点表达式以匹配特定的方法。\n\n**暂时写到这里，以后会接着更新文档**', '<h1><a id=\"1_SpringAOP_0\"></a>1. SpringAOP的基本概念</h1>\n<p>SpringAOP（Aspect-Oriented Programming）即面向切面编程，是Spring框架体系中非常重要的功能模块之一。AOP与OOP（面向对象编程）相辅相成，提供了一种与OOP不同的抽象软件结构的视图。</p>\n<p>在OOP中，程序的基本单元是类，而AOP的基本单元是Aspect（切面），切面能够对那些影响多个类的公共行为进行封装。这种“横切”的技术，将封装对象内部剖解开，将那些影响多个类的公共方法封装到一个可重用的模块中，从而减少系统的重复代码，降低模块间的耦合度，提高系统的可操作性和可维护性。</p>\n<p>AOP采取横向抽取机制，取代了传统纵向继承体系中的重复性代码。在业务处理代码中，如日志记录、性能统计、安全控制、事务处理、异常处理等操作，尽管使用OOP可以通过封装或继承的方式达到代码的重用，但仍然有相同的代码分散在各个方法中。而AOP则能够将这些操作封装到独立的模块中，使关注点代码与业务代码分离，从而简化了程序结构，提高了代码的可读性和可维护性。</p>\n<p>AOP中的关键概念包括：</p>\n<ol>\n<li>Joinpoint（连接点）：类中可以被增强的方法。</li>\n<li>Pointcut（切入点）：实际被增强的方法，即在类中可以有很多方法被增强，但实际被增强的方法被称为切入点。</li>\n<li>Advice（通知/增强）：增强的逻辑，即具体的切面逻辑代码。</li>\n</ol>\n<p>总的来说，SpringAOP通过面向切面编程的方式，提供了一种灵活且强大的机制，用于处理那些跨越多个类和方法的公共行为，从而提高了软件系统的可维护性和可扩展性。</p>\n<p>AOP中的关键概念包括：</p>\n<p>Joinpoint（连接点）：类中可以被增强的方法。</p>\n<p>Pointcut（切入点）：实际被增强的方法，即在类中可以有很多方法被增强，但实际被增强的方法被称为切入点。</p>\n<p>Advice（通知/增强）：增强的逻辑，即具体的切面逻辑代码。</p>\n<p>总的来说，SpringAOP通过面向切面编程的方式，提供了一种灵活且强大的机制，用于处理那些跨越多个类和方法的公共行为，从而提高了软件系统的可维护性和可扩展性。</p>\n<h1><a id=\"2AOP_26\"></a>2.AOP代码执行顺序</h1>\n<p>在Spring AOP（Aspect-Oriented Programming）中，当使用环绕通知（Around Advice）时，代码的执行顺序遵循以下逻辑：</p>\n<ol>\n<li>\n<p><strong>前置通知（Before Advice）</strong>: 如果定义了前置通知，它会在目标方法执行之前被调用。前置通知主要用于执行一些准备性的工作，比如开启事务、设置参数等。</p>\n</li>\n<li>\n<p><strong>环绕通知（Around Advice）开始</strong>: 环绕通知是AOP中最强大的通知类型，因为它允许你在目标方法执行前后进行自定义的逻辑处理。当目标方法被调用时，环绕通知的逻辑开始执行。</p>\n</li>\n<li>\n<p><strong>环绕通知内部逻辑</strong>: 在环绕通知中，你可以决定是否继续执行目标方法，以及何时执行。这通过<code>ProceedingJoinPoint</code>的<code>proceed()</code>方法来实现。如果你希望在目标方法执行前做一些处理，可以在调用<code>proceed()</code>之前完成；如果需要在目标方法执行后做处理，可以在<code>proceed()</code>之后完成。</p>\n</li>\n<li>\n<p><strong>目标方法执行</strong>: 当环绕通知中的<code>proceed()</code>方法被调用时，目标方法开始执行。这是实际业务逻辑的部分。</p>\n</li>\n<li>\n<p><strong>环绕通知后续逻辑</strong>: 在目标方法执行完毕后，环绕通知的后续逻辑将执行。这通常包括一些清理工作，比如关闭资源、提交或回滚事务等。</p>\n</li>\n<li>\n<p><strong>后置通知（After Advice）</strong>: 如果定义了后置通知，它会在目标方法执行之后（无论目标方法是否成功执行）被调用。后置通知通常用于执行一些清理或日志记录工作。</p>\n</li>\n<li>\n<p><strong>异常通知（After Throwing Advice）</strong>: 如果目标方法抛出了异常，并且定义了异常通知，那么异常通知将在异常被抛出后执行。这允许你执行一些特定的异常处理逻辑。</p>\n</li>\n<li>\n<p><strong>返回通知（After Returning Advice）</strong>: 如果定义了返回通知，并且目标方法成功返回了结果，那么返回通知将在目标方法返回结果之后执行。这通常用于处理方法的返回值。</p>\n</li>\n</ol>\n<blockquote>\n<p>总结来说，Spring AOP中的代码执行顺序是：前置通知 -&gt; 环绕通知开始 -&gt; 目标方法执行 -&gt; 环绕通知后续逻辑 -&gt; 后置通知/异常通知/返回通知。</p>\n</blockquote>\n<blockquote>\n<p>注意：以上顺序基于Spring AOP的默认行为，但可以通过配置或编程方式改变通知的执行顺序。</p>\n</blockquote>\n<h1><a id=\"3_SpringAop_51\"></a>3. SpringAop常用注解</h1>\n<p>Spring AOP（Aspect-Oriented Programming）常用的注解包括：</p>\n<ol>\n<li>\n<p><code>@Aspect</code>: 该注解用于声明一个类为切面类，即这个类将包含一些通知（Advice）和切入点（Pointcut）的定义。</p>\n</li>\n<li>\n<p><code>@Pointcut</code>: 该注解用于定义一个切入点，切入点是一个表达式，它指定了在哪些方法执行时要应用通知。切入点表达式通常基于方法签名、异常类型、注解等来定义匹配规则。</p>\n</li>\n<li>\n<p><code>@Before</code>: 该注解用于定义前置通知（Before Advice），即目标方法执行之前的通知。前置通知常用于执行一些准备性的工作，如设置参数、开启事务、申请资源等。</p>\n</li>\n<li>\n<p><code>@After</code>: 该注解用于定义后置通知（After Advice），即目标方法执行之后的通知。后置通知常用于执行一些清理工作，如关闭资源、记录日志等。</p>\n</li>\n<li>\n<p><code>@AfterReturning</code>: 该注解用于定义返回后通知（After Returning Advice），即目标方法正常返回之后的通知。这个通知可以获取到目标方法的返回值，并进行相应的处理。</p>\n</li>\n<li>\n<p><code>@AfterThrowing</code>: 该注解用于定义异常后通知（After Throwing Advice），即目标方法抛出异常之后的通知。这个通知可以在异常处理逻辑中发挥作用，如记录异常信息、进行回滚操作等。</p>\n</li>\n<li>\n<p><code>@Around</code>: 该注解用于定义环绕通知（Around Advice），即在目标方法执行前后都进行通知。环绕通知可以控制目标方法的执行流程，如是否执行目标方法、何时执行目标方法等。</p>\n</li>\n</ol>\n<p>为了使Spring AOP生效，你还需要在Spring配置中启用AspectJ自动代理，这通常通过在配置类上添加<code>@EnableAspectJAutoProxy</code>注解来实现。同时，你还需要确保切面类被Spring容器管理，通常通过在切面类上添加<code>@Component</code>注解来实现。</p>\n<h1><a id=\"4__70\"></a>4. 另外举几个例子说明</h1>\n<h2><a id=\"Aspect_71\"></a>@Aspect</h2>\n<p><code>@Aspect</code> 是 Spring AOP（Aspect-Oriented Programming）中的一个关键注解，用于定义一个切面（Aspect）。切面是 AOP 的核心概念之一，它代表了横切关注点（cross-cutting concerns）的模块化实现。这些关注点通常包括日志记录、事务管理、权限验证等，它们跨越多个应用层次和多个类，因此不适合直接放在业务逻辑代码中。</p>\n<p><code>@Aspect</code> 注解通常标注在一个类上，该类随后会被 Spring 容器识别为一个切面类，并且其中的通知（Advice）和切入点（Pointcut）会被容器自动处理。切面类可以包含多种类型的通知，如前置通知（<code>@Before</code>）、后置通知（<code>@After</code>）、返回后通知（<code>@AfterReturning</code>）、异常后通知（<code>@AfterThrowing</code>）以及环绕通知（<code>@Around</code>）。</p>\n<p>下面是一个简单的例子，展示了如何使用 <code>@Aspect</code> 注解定义一个切面类：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Before;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingAspect</span> </span>{\n\n    <span class=\"hljs-comment\">// 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法</span>\n    <span class=\"hljs-meta\">@Pointcut</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">serviceMethods</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-comment\">// 使用 @Before 注解定义一个前置通知</span>\n    <span class=\"hljs-meta\">@Before</span>(<span class=\"hljs-string\">\"serviceMethods()\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">logBefore</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Method is being called\"</span>);\n        <span class=\"hljs-comment\">// 在这里可以添加日志记录的逻辑</span>\n    }\n\n    <span class=\"hljs-comment\">// 其他通知方法...</span>\n}\n</code></div></pre>\n<p>在这个例子中，<code>LoggingAspect</code> 类被标注为 <code>@Aspect</code>，意味着它是一个切面类。该类定义了一个切入点 <code>serviceMethods()</code>，它匹配 <code>com.example.service</code> 包下所有类的所有方法。然后，使用 <code>@Before</code> 注解定义了一个前置通知 <code>logBefore()</code>，该通知会在匹配切入点的方法执行之前执行。</p>\n<p>要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，这通常通过在配置类上添加 <code>@EnableAspectJAutoProxy</code> 注解来实现。此外，确保切面类被 Spring 容器管理，通常通过在类上添加 <code>@Component</code> 注解来实现。这样，当目标方法被调用时，相应的通知就会根据切入点的规则被触发执行。</p>\n<h2><a id=\"Pointcut_106\"></a>@Pointcut</h2>\n<p>在Spring AOP（Aspect-Oriented Programming）中，<code>@Pointcut</code>是一个注解，用于定义一个切入点（Pointcut）。切入点是一个表达式，它指定了在哪些方法执行时要应用通知（Advice）。简而言之，<code>@Pointcut</code>注解允许你定义一个规则，当这个规则匹配时，相应的通知（如前置通知、后置通知、异常通知等）就会被触发。</p>\n<p><code>@Pointcut</code>注解通常定义在一个方法上，这个方法没有返回类型，并且通常没有方法体（或者方法体为空）。这个方法的名称代表了切入点的名称，而方法的参数则是一个切入点表达式，用于指定哪些方法匹配该切入点。</p>\n<p>切入点表达式通常使用AspectJ的表达式语言编写，可以基于方法签名（如方法名、参数类型、返回类型等）、异常类型、注解等来定义匹配规则。</p>\n<p>下面是一个简单的例子，展示了如何使用<code>@Pointcut</code>注解来定义一个切入点：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Pointcut;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAspect</span> </span>{\n\n    <span class=\"hljs-comment\">// 定义一个切入点，匹配com.example.service包下所有类的所有方法</span>\n    <span class=\"hljs-meta\">@Pointcut</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">serviceMethods</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 方法体为空，因为@Pointcut注解定义的是一个切入点规则，而不是具体的业务逻辑</span>\n    }\n\n    <span class=\"hljs-comment\">// 其他通知（Advice）可以使用这个切入点</span>\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p>在这个例子中，<code>serviceMethods</code>方法定义了一个切入点，它匹配<code>com.example.service</code>包下所有类的所有方法。之后，你可以在其他通知方法中使用<code>serviceMethods()</code>作为切入点表达式，来指定这些通知应该在哪些方法执行时应用。</p>\n<p><code>@Pointcut</code>注解使得切入点定义更加集中和易于管理，你可以在同一个Aspect类中定义多个切入点，然后在不同的通知中重复使用这些切入点。这有助于提高代码的可读性和可维护性。</p>\n<h2><a id=\"Before_136\"></a>@Before</h2>\n<p>在Spring AOP（Aspect-Oriented Programming）中，<code>@Before</code>注解用于定义前置通知（Before Advice）。前置通知在目标方法执行之前执行，通常用于执行一些准备性的工作，如设置参数、开启事务、申请资源等。</p>\n<p>使用<code>@Before</code>注解的方法通常会接收一个<code>JoinPoint</code>参数，它代表了一个连接点（即一个方法的执行）。你可以通过这个参数获取关于目标方法的信息，如方法名、参数等。</p>\n<p>下面是一个使用<code>@Before</code>注解的示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.JoinPoint;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Before;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAspect</span> </span>{\n\n    <span class=\"hljs-meta\">@Before</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">logBeforeMethod</span><span class=\"hljs-params\">(JoinPoint joinPoint)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"About to execute method: \"</span> + joinPoint.getSignature().getName());\n        <span class=\"hljs-comment\">// 这里可以添加一些准备性的工作，如开启事务、申请资源等</span>\n    }\n}\n</code></div></pre>\n<p>在这个示例中，<code>@Before</code>注解定义了一个前置通知<code>logBeforeMethod</code>，它会在<code>com.example.service</code>包下所有类的所有方法执行之前执行。通知方法接收一个<code>JoinPoint</code>参数，允许你获取关于即将执行的方法的信息。</p>\n<p>前置通知通常用于执行一些与目标方法执行相关的前置条件检查或资源准备工作。例如，你可能需要在执行数据库操作之前开启事务，或者在调用某个服务之前申请必要的资源。</p>\n<p>请注意，<code>@Before</code>注解的切入点表达式决定了哪些方法执行前会触发这个通知。在上面的示例中，切入点表达式<code>execution(* com.example.service.*.*(..))</code>意味着所有在<code>com.example.service</code>包下的类的所有方法执行前都会触发这个通知。</p>\n<p>最后，和<code>@After</code>注解一样，你需要在Spring配置中启用AspectJ自动代理，以便Spring能够识别和处理这些方面（Aspects）。这通常通过在配置类上添加<code>@EnableAspectJAutoProxy</code>注解来实现。</p>\n<h2><a id=\"After_171\"></a>@After</h2>\n<p>在Spring AOP（Aspect-Oriented Programming）中，<code>@After</code>注解用于定义后置通知（After Advice）。后置通知在目标方法执行完毕之后执行，无论目标方法是否成功完成（即无论是否抛出异常）。这意味着，即使目标方法抛出异常，后置通知也会被触发。</p>\n<p>使用<code>@After</code>注解的方法通常会接收一个<code>JoinPoint</code>参数，它代表了一个连接点（即一个方法的执行）。然而，<code>@After</code>通知通常不需要这个参数，因为它是在目标方法执行完毕之后运行的，此时你已经无法影响目标方法的执行了。</p>\n<p>下面是一个使用<code>@After</code>注解的示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.After;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingAspect</span> </span>{\n\n    <span class=\"hljs-meta\">@After</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">logAfterMethod</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Method has been executed.\"</span>);\n    }\n}\n</code></div></pre>\n<p>在这个示例中，<code>@After</code>注解定义了一个后置通知<code>logAfterMethod</code>，它会在<code>com.example.service</code>包下所有类的所有方法执行完毕后执行。通知方法没有接收任何参数，因为它只是简单地打印一条消息，表明方法已经执行完毕。</p>\n<p>请注意，<code>@After</code>注解的切入点表达式决定了哪些方法执行后会触发这个通知。在上面的示例中，切入点表达式<code>execution(* com.example.service.*.*(..))</code>意味着所有在<code>com.example.service</code>包下的类的所有方法执行后都会触发这个通知。</p>\n<p>后置通知通常用于执行一些清理工作、日志记录或监视任务，这些任务需要在方法执行后但不需要考虑方法是否成功执行的情况下执行。</p>\n<p>最后，请记住要在Spring配置中启用AspectJ自动代理，以便Spring能够识别和处理这些方面（Aspects）。这通常通过在配置类上添加<code>@EnableAspectJAutoProxy</code>注解来实现。</p>\n<h2><a id=\"AfterReturning_202\"></a>@AfterReturning</h2>\n<p><code>@AfterReturning</code> 是 Spring AOP（Aspect-Oriented Programming）中的一个注解，用于定义一个返回后通知（After Returning Advice）。这种通知会在被切点方法正常执行并返回之后执行，它允许你访问到被切点方法的返回值，并根据这个返回值进行一些后续的处理操作。</p>\n<p>这个注解通常用于执行一些在方法执行成功后的逻辑，比如根据方法的返回结果更新某些状态、记录日志、发送通知等。</p>\n<p><code>@AfterReturning</code> 注解有几个重要的属性：</p>\n<ul>\n<li><code>pointcut</code> 或 <code>value</code>：用于指定切入点表达式，确定哪些方法的执行会触发这个通知。</li>\n<li><code>returning</code>：指定一个参数名，这个参数会接收被切点方法的返回值，你可以在通知方法中通过这个参数访问到返回值。</li>\n</ul>\n<p>下面是一个使用 <code>@AfterReturning</code> 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.JoinPoint;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.AfterReturning;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingAspect</span> </span>{\n\n    <span class=\"hljs-comment\">// 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法</span>\n    <span class=\"hljs-meta\">@Pointcut</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">serviceMethods</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-comment\">// 使用 @AfterReturning 注解定义一个返回后通知</span>\n    <span class=\"hljs-meta\">@AfterReturning</span>(pointcut = <span class=\"hljs-string\">\"serviceMethods()\"</span>, returning = <span class=\"hljs-string\">\"result\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">logAfterReturning</span><span class=\"hljs-params\">(JoinPoint joinPoint, Object result)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Method executed successfully: \"</span> + joinPoint.getSignature().getName());\n        System.out.println(<span class=\"hljs-string\">\"Returned value: \"</span> + result);\n        <span class=\"hljs-comment\">// 在这里可以根据返回值进行一些处理，比如记录日志、更新状态等</span>\n    }\n}\n</code></div></pre>\n<p>在这个例子中，<code>logAfterReturning</code> 方法是一个返回后通知，它会在 <code>serviceMethods()</code> 切入点匹配的方法成功执行后执行。通过 <code>returning = &quot;result&quot;</code> 指定了一个参数名 <code>result</code>，这个参数会接收被切点方法的返回值，然后在通知方法中打印出来。</p>\n<p>要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，并确保切面类被 Spring 容器管理。这样，当目标方法成功执行并返回后，相应的返回后通知就会根据切入点的规则被触发执行。</p>\n<h2><a id=\"AfterThrowing_243\"></a>@AfterThrowing</h2>\n<p><code>@AfterThrowing</code> 是 Spring AOP（Aspect-Oriented Programming）中的一个注解，用于定义一个异常后通知（After Throwing Advice）。这个通知在被切点方法抛出异常时执行，允许你在方法发生异常时执行一些逻辑，如记录异常信息、进行清理工作、回滚事务等。</p>\n<p><code>@AfterThrowing</code> 注解有几个重要的属性：</p>\n<ul>\n<li><code>pointcut</code> 或 <code>value</code>：用于指定切入点表达式，确定哪些方法的异常会触发这个通知。</li>\n<li><code>throwing</code>：指定一个参数名，该参数将接收被切点方法抛出的异常对象，允许你在通知方法中访问并处理这个异常。</li>\n</ul>\n<p>下面是一个使用 <code>@AfterThrowing</code> 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> org.aspectj.lang.JoinPoint;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.AfterThrowing;\n<span class=\"hljs-keyword\">import</span> org.aspectj.lang.annotation.Aspect;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Aspect</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExceptionHandlingAspect</span> </span>{\n\n    <span class=\"hljs-comment\">// 定义一个切入点，匹配 com.example.service 包下的所有类的所有方法</span>\n    <span class=\"hljs-meta\">@Pointcut</span>(<span class=\"hljs-string\">\"execution(* com.example.service.*.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">serviceMethods</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-comment\">// 使用 @AfterThrowing 注解定义一个异常后通知</span>\n    <span class=\"hljs-meta\">@AfterThrowing</span>(pointcut = <span class=\"hljs-string\">\"serviceMethods()\"</span>, throwing = <span class=\"hljs-string\">\"ex\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleException</span><span class=\"hljs-params\">(JoinPoint joinPoint, Throwable ex)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Method failed: \"</span> + joinPoint.getSignature().getName());\n        System.out.println(<span class=\"hljs-string\">\"Thrown exception: \"</span> + ex.getMessage());\n        <span class=\"hljs-comment\">// 在这里可以记录异常信息、进行清理工作、回滚事务等</span>\n    }\n}\n</code></div></pre>\n<p>在这个例子中，<code>handleException</code> 方法是一个异常后通知，它会在 <code>serviceMethods()</code> 切入点匹配的方法抛出异常时执行。通过 <code>throwing = &quot;ex&quot;</code> 指定了一个参数名 <code>ex</code>，这个参数会接收被切点方法抛出的异常对象，然后在通知方法中打印出异常信息。</p>\n<p>要使这个切面类生效，你需要在 Spring 配置中启用 AspectJ 自动代理，并确保切面类被 Spring 容器管理。这样，当目标方法抛出异常时，相应的异常后通知就会根据切入点的规则被触发执行。</p>\n<p>通过结合使用 <code>@Pointcut</code> 来定义复用的切入点表达式，你可以使通知的定义更加简洁和可维护。同时，Spring AOP 还支持其他类型的通知，如 <code>@Before</code>（前置通知）、<code>@After</code>（后置通知）和 <code>@Around</code>（环绕通知），它们提供了在方法执行的不同阶段执行自定义逻辑的能力。</p>\n<h2><a id=\"Around_284\"></a>@Around</h2>\n<p>在Spring AOP中，@Around注解用于定义环绕通知（Around Advice），它是最强大的一种通知类型，因为它允许你在目标方法执行前后进行自定义的逻辑处理，并且可以决定是否继续执行目标方法以及何时执行。</p>\n<p>当你使用@Around注解时，你需要定义一个方法，这个方法将接收一个ProceedingJoinPoint参数，这个参数代表了被通知方法的执行点。你可以在这个方法内部实现自己的逻辑，比如前置处理、后置处理、异常处理等。</p>\n<p>下面是一个使用@Around注解的示例：</p>\n<pre><code class=\"lang-\">import org.aspectj.lang.ProceedingJoinPoint;  \nimport org.aspectj.lang.annotation.Around;  \nimport org.aspectj.lang.annotation.Aspect;  \nimport org.springframework.stereotype.Component;  \n  \n@Aspect  \n@Component  \npublic class MyAspect {  \n  \n    @Around(&quot;execution(* com.example.service.*.*(..))&quot;)  \n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {  \n        long start = System.currentTimeMillis();  \n  \n        Object proceed = joinPoint.proceed(); // 继续执行目标方法  \n  \n        long executionTime = System.currentTimeMillis() - start;  \n  \n        System.out.println(joinPoint.getSignature() + &quot; executed in &quot; + executionTime + &quot;ms&quot;);  \n  \n        return proceed;  \n    }  \n}\n</code></pre>\n<p>在这个示例中，@Around注解用于定义一个环绕通知，它会在com.example.service包下所有类的所有方法执行前后起作用。通知方法logExecutionTime接收一个ProceedingJoinPoint参数，允许你在执行目标方法之前和之后插入自定义逻辑。</p>\n<p>在logExecutionTime方法中：</p>\n<p>记录方法开始执行的时间。<br />\n调用proceed()方法执行目标方法。<br />\n记录方法执行结束的时间，并计算执行时长。<br />\n打印方法的执行时长。<br />\n如果proceed()方法没有被调用，那么目标方法将不会被执行。这意味着你可以在环绕通知中根据某些条件决定是否继续执行目标方法。</p>\n<p>请注意，为了使用@Around注解，你需要在Spring配置中启用AspectJ自动代理，这通常通过在配置类上添加@EnableAspectJAutoProxy注解来实现。</p>\n<p>此外，@Around注解中的切入点表达式（Pointcut Expression）决定了哪些方法会被这个通知所影响。在上面的示例中，切入点表达式execution(* com.example.service.<em>.</em>(…))意味着所有在com.example.service包下的类的所有方法都会被这个通知所影响。你可以根据需要调整切入点表达式以匹配特定的方法。</p>\n<p><strong>暂时写到这里，以后会接着更新文档</strong></p>\n', 1770444117323571201);

-- ----------------------------
-- Table structure for ms_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_tag`;
CREATE TABLE `ms_article_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1770444699165810691 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article_tag
-- ----------------------------
INSERT INTO `ms_article_tag` VALUES (1, 1, 7);
INSERT INTO `ms_article_tag` VALUES (2, 1, 5);
INSERT INTO `ms_article_tag` VALUES (3, 1, 8);
INSERT INTO `ms_article_tag` VALUES (4, 9, 7);
INSERT INTO `ms_article_tag` VALUES (5, 10, 7);
INSERT INTO `ms_article_tag` VALUES (6, 10, 8);
INSERT INTO `ms_article_tag` VALUES (7, 10, 5);
INSERT INTO `ms_article_tag` VALUES (8, 10, 6);
INSERT INTO `ms_article_tag` VALUES (1405564731321802753, 1405564731300831233, 5);
INSERT INTO `ms_article_tag` VALUES (1405909844761800706, 1405909844724051969, 5);
INSERT INTO `ms_article_tag` VALUES (1405916999787233281, 1405916999732707330, 5);
INSERT INTO `ms_article_tag` VALUES (1662117613662142467, 1662117613662142466, 8);
INSERT INTO `ms_article_tag` VALUES (1760583060224528386, 1760583060186779650, 8);
INSERT INTO `ms_article_tag` VALUES (1761394422383239170, 1761384608915554306, 6);
INSERT INTO `ms_article_tag` VALUES (1762684501273620482, 1760687849444749313, 9);
INSERT INTO `ms_article_tag` VALUES (1770444117394874369, 1770444117323571201, 6);
INSERT INTO `ms_article_tag` VALUES (1770444117394874370, 1770444117323571201, 7);
INSERT INTO `ms_article_tag` VALUES (1770444699165810690, 1608050952827342850, 8);

-- ----------------------------
-- Table structure for ms_category
-- ----------------------------
DROP TABLE IF EXISTS `ms_category`;
CREATE TABLE `ms_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_category
-- ----------------------------
INSERT INTO `ms_category` VALUES (1, '/static/category/front.png', '前端', '前端是什么，大前端');
INSERT INTO `ms_category` VALUES (2, '/static/category/back.png', '后端', '后端最牛');
INSERT INTO `ms_category` VALUES (3, '/static/category/lift.jpg', '生活', '生活趣事');
INSERT INTO `ms_category` VALUES (4, '/static/category/database.png', '数据库', '没数据库，啥也不管用');
INSERT INTO `ms_category` VALUES (5, '/static/category/language.png', '编程语言与基础算法', '好多语言，该学哪个？算法又该如何开始学习?');

-- ----------------------------
-- Table structure for ms_comment
-- ----------------------------
DROP TABLE IF EXISTS `ms_comment`;
CREATE TABLE `ms_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(20) NOT NULL,
  `article_id` bigint(11) NOT NULL,
  `author_id` bigint(20) NOT NULL,
  `parent_id` bigint(20) NOT NULL,
  `to_uid` bigint(20) NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1770450239426158595 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_comment
-- ----------------------------
INSERT INTO `ms_comment` VALUES (53, '写的好', 123213213213, 1, 1, 0, 1, '1');
INSERT INTO `ms_comment` VALUES (54, '111', 123123123123, 1, 1, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (56, '222', 12312, 1, 1, 0, 1, '1');
INSERT INTO `ms_comment` VALUES (1405204547248377858, '123', 1623861846172, 1, 1, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (1405205050975899650, '123123', 1623861966270, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405205572185280513, '3333', 1623862090534, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405206087392612353, '7777', 1623862213367, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405206147568291842, '7777', 1623862227714, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405206347246522370, '666', 1623862275315, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405208637198131202, '99999999999999999999', 1623862821278, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1405209691876790274, '66666666666666666', 1623863072732, 1, 1, 1405208637198131202, 1, '2');
INSERT INTO `ms_comment` VALUES (1599406523954561026, '太强啦', 1670163205499, 1, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1599406632566063105, '问一下大佬是那个学校的', 1670163231410, 1, 1592051100003860482, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (1599406778620116993, '## sdasd', 1670163266232, 1, 1592051100003860482, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (1608051269472129025, '撒旦', 1672224273447, 1, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1608051315827576834, 'lxc', 1672224284508, 1, 1592051100003860482, 1608051269472129025, 1592051100003860500, '2');
INSERT INTO `ms_comment` VALUES (1608054282374901761, 'sad ', 1672224991786, 9, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1608058400686489601, 'xca', 1672225973674, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1608058737367461889, '15', 1672226053873, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1608059242391040002, '撒大都市', 1672226174335, 1608050952827342850, 1592051100003860482, 1608058400686489601, 1592051100003860500, '2');
INSERT INTO `ms_comment` VALUES (1608059464693346305, '了，acd', 1672226227352, 1, 1592051100003860482, 1405205050975899650, 1, '2');
INSERT INTO `ms_comment` VALUES (1608059654594654209, '@李四 十大阿三', 1672226272625, 1, 1592051100003860482, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (1608760775063666690, '156按上次', 1672393432757, 1, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1662116777401810945, '15\n', 1685114495021, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1662116811086266370, '16', 1685114503068, 1608050952827342850, 1592051100003860482, 1608058400686489601, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1662116885254144001, '156', 1685114520751, 1, 1592051100003860482, 53, 1, '2');
INSERT INTO `ms_comment` VALUES (1662116935975862274, '56', 1685114532847, 1, 1592051100003860482, 56, 1, '2');
INSERT INTO `ms_comment` VALUES (1715384738593660930, '感谢大家积极评论', 1697814566641, 1662117613662142466, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1715384867677560833, '感谢楼主的分享hhhh', 1697814597422, 1662117613662142466, 1597801008459800578, 1715384738593660930, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1715384983637483521, '哈哈哈哈', 1697814625083, 1662117613662142466, 1592051100003860482, 1715384738593660930, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1715385084690849794, '我会和楼主一起努力的', 1697814649162, 1662117613662142466, 1592051100003860482, 1715384738593660930, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1740008481697591298, '的撒大都市', 1703685324482, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1740223134029611009, '撒旦', 1703736501583, 1662117613662142466, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1740223420727066626, '阿松大阿迪斯', 1703736569950, 1662117613662142466, 1592051100003860482, 1715384738593660930, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1760526830701383682, '15', 1708577280098, 1662117613662142466, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760542138770178049, '蚌埠住了', 1708580929826, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760542261180940289, '哈哈哈哈', 1708580959018, 1608050952827342850, 1592051100003860482, 1760542138770178049, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1760543557942366210, '写的不错', 1708581268184, 1405916999732707300, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760543625386774530, '赞', 1708581284267, 1405916999732707300, 1592051100003860482, 1760543557942366210, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1760543680265048065, 'hhhhhhhhhh', 1708581297364, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760546280985174017, 'happy\n', 1708581917407, 9, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760547467356643330, '加油', 1708582200267, 9, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760551492856676353, '1', 1708583160013, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760551617507196930, '2', 1708583189753, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760555298491248641, '3', 1708584067349, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760555539483402242, '4', 1708584124807, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760556656879521793, '5', 1708584391164, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760556750303449089, '6', 1708584413495, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760560687265878017, '7', 1708585352132, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760562334931103745, '8', 1708585744967, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760563560129351682, '9', 1708586037076, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760565952392466434, '10', 1708586607438, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760565995962896385, '11', 1708586617829, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760620603896868866, '加油博主！！', 1708599637370, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760650138000306178, '今天比赛上分啦，哈哈哈哈\n', 1708606678850, 1760583060186779650, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760667404301516802, 'cheer up!', 1708610795455, 1662117613662142466, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1760884694922158082, '12', 1708662601578, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1761386422037676034, '13', 1708782222649, 10, 1597801008459800578, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1761765711883083778, '加油哇', 1708872652396, 1760687849444749313, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762678495076511745, '努力', 1709090276868, 1760687849444749313, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762679863371673601, '一起努力呀', 1709090603089, 1760687849444749313, 1592051100003860482, 1761765711883083778, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1762682678307500034, '写的很不错', 1709091274225, 1760583060186779650, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762682746838233089, '加油哦\n', 1709091290573, 1760583060186779650, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762683598143520770, '14', 1709091493528, 10, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762684195282366465, '努力进步', 1709091635896, 1760687849444749313, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762686902818902018, 'sofa', 1709092281426, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762688376676306946, '哈哈哈', 1709092632822, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762700454434799617, '？', 1709095512380, 1662117613662142466, 1592051100003860482, 1740223134029611009, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1762700847919235073, '一起加油啊', 1709095606206, 1760687849444749313, 1597801008459800578, 1761765711883083778, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1762701340326330369, '赞', 1709095723603, 1760687849444749313, 1597801008459800578, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762702817933520897, '赞', 1709096075884, 1760687849444749313, 1597801008459800578, 1762684195282366465, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1762702894311796737, '努力', 1709096094099, 1760687849444749313, 1597801008459800578, 1761765711883083778, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1762702998456365058, '写的非常好', 1709096118940, 1760687849444749313, 1597801008459800578, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762706914975694849, '156', 1709097052699, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1762707753874247682, '+', 1709097252704, 1608050952827342850, 1592051100003860482, 1608058737367461889, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1765375412034088962, '兄弟加油啊\n', 1709733271970, 1608050952827342850, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1765375438424649730, '哈哈哈', 1709733278268, 1608050952827342850, 1592051100003860482, 1765375412034088962, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1765375598177300481, '你哈', 1709733316356, 9, 1592051100003860482, 1608054282374901761, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1765382437426196481, '加油奥利给', 1709734946955, 1760687849444749313, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1765382607303897090, '加油兄弟', 1709734987459, 1760687849444749313, 1597801008459800578, 1765382437426196481, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1765383518789070850, 'ヾ(◍°∇°◍)ﾉﾞ', 1709735204779, 1760687849444749313, 1597801008459800578, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1765383609797079041, 'lxc', 1709735226473, 1760687849444749313, 1592051100003860482, 1765383518789070850, 1597801008459800578, '2');
INSERT INTO `ms_comment` VALUES (1770387076370526209, 'vue总体框架还是可以的！！', 1710928145858, 9, 1592051100003860482, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1770449436258885633, '@lxc哈哈哈', 1710943013619, 1662117613662142466, 1592051100003860482, 1715384738593660930, 1592051100003860482, '2');
INSERT INTO `ms_comment` VALUES (1770450239426158594, '大家好，欢迎评论！', 1710943205114, 1770444117323571201, 1592051100003860482, 0, 0, '1');

-- ----------------------------
-- Table structure for ms_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_permission`;
CREATE TABLE `ms_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_permission
-- ----------------------------
INSERT INTO `ms_permission` VALUES (1, '查询权限列表', '/admin/permission/permissionList', '查询权限列表');
INSERT INTO `ms_permission` VALUES (8, '删除权限', '/admin/permission/delete', '删除权限');
INSERT INTO `ms_permission` VALUES (9, '新增权限', '/admin/permission/add', '新增权限');
INSERT INTO `ms_permission` VALUES (10, '更新权限', '/admin/permission/update', '更新权限');

-- ----------------------------
-- Table structure for ms_sys_log
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_log`;
CREATE TABLE `ms_sys_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` bigint(20) NULL DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `time` bigint(20) NULL DEFAULT NULL,
  `userid` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for ms_sys_user
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_user`;
CREATE TABLE `ms_sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(20) NULL DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1597801008459800579 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_sys_user
-- ----------------------------
INSERT INTO `ms_sys_user` VALUES (1, 'admin', b'1', 'http://localhost:8080/static/img/logo.b3a48c0.png', 20210622223122, b'0', '11', 20210630223130, '12', '李四', '15f08f86435b060236fa9ccea751e9e5', '12', '1');
INSERT INTO `ms_sys_user` VALUES (1404446129264832513, 'lisi', b'1', '/static/img/logo.b3a48c0.png', 1623681025218, b'0', '', 1623681025218, NULL, '李四', '1d01d52c40f4ff57ad3f93a06daf21d5', '', '');
INSERT INTO `ms_sys_user` VALUES (1404448463944462338, '123123', b'1', '/static/img/logo.b3a48c0.png', 1623681581855, b'0', '', 1623681581855, NULL, '123', '8628d1f407f72e10ac947a032fe5ad29', '', '');
INSERT INTO `ms_sys_user` VALUES (1404448588146192386, '123', b'1', '/static/img/logo.b3a48c0.png', 1623681611474, b'0', '', 1623681611474, NULL, '123', '5e112646dbf3570f8e23d0cf1027ede1', '', '');
INSERT INTO `ms_sys_user` VALUES (1592051100003860482, 'marvel', b'1', '/static/img/logo.b3a48c0.png', 1668409535787, b'0', '', 1668409535787, NULL, 'marvel', '28d5d9f11c206c76ecbdbf4ef1e1661a', '', '');
INSERT INTO `ms_sys_user` VALUES (1597801008459800578, 'lxc', b'1', '/static/img/logo.b3a48c0.png', 1669780420774, b'0', '', 1669780420774, NULL, 'lxc', '28d5d9f11c206c76ecbdbf4ef1e1661a', '', '');

-- ----------------------------
-- Table structure for ms_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_tag`;
CREATE TABLE `ms_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_tag
-- ----------------------------
INSERT INTO `ms_tag` VALUES (5, '/static/tag/java.png', 'springboot');
INSERT INTO `ms_tag` VALUES (6, '/static/tag/java.png', 'spring');
INSERT INTO `ms_tag` VALUES (7, '/static/tag/java.png', 'springmvc');
INSERT INTO `ms_tag` VALUES (8, '/static/tag/css.png', '其他');
INSERT INTO `ms_tag` VALUES (9, '/static/tag/algorithm.png', '算法');

SET FOREIGN_KEY_CHECKS = 1;
